%!TEX root = std.tex
%%--------------------------------------------------
%% Title page for the C++ Standard


\thispagestyle{empty}
\begingroup
\def\hd{\begin{tabular}{ll}
          \textbf{Document Number:} & P1622R3                      \\
          \textbf{Date:}            & \reldate                     \\
          \textbf{Reply to:}        & Daniel Sunderland            \\
                                    & Sandia National Laboratories \\
                                    & dsunder@sandia.gov
          \end{tabular}
}
\newlength{\hdwidth}
\settowidth{\hdwidth}{\hd}
\hfill\begin{minipage}{\hdwidth}\hd\end{minipage}
\endgroup

\vspace{2.5cm}
\begin{center}
\textbf{\Huge
Mandating the Standard Library:\\Clause 32 - Thread support library}
\end{center}

With the adoption of P0788R3, we have a new way of specifying requirements for the
library clauses of the standard. This is one of a series of papers reformulating the
requirements into the new format. This effort was strongly influenced by the informational
paper P1369R0.

The changes in this series of papers fall into four broad categories.
\begin{itemize}
\item{Change "participate in overload resolution" wording into "Constraints" elements}
\item{Change "Requires" elements into either "Mandates" or "Expects", depending (mostly) on whether or not they can be checked at compile time.}
\item{Drive-by fixes (hopefully very few)}
\end{itemize}

This paper covers Clause 32 (Thread Support Library)

The entire clause is reproduced here, but the changes are confined to a few sections:

\begin{multicols}{2}
\begin{itemize}
\item{thread.req.paramname                  \ref{thread.req.paramname}}
\item{thread.req.exception                  \ref{thread.req.exception}}
\item{thread.req.lockable.general           \ref{thread.req.lockable.general}}
\item{thread.req.lockable.basic             \ref{thread.req.lockable.basic}}
\item{thread.thread.class                   \ref{thread.thread.class}}
\item{thread.thread.constr                  \ref{thread.thread.constr}}
\item{thread.thread.member                  \ref{thread.thread.member}}
\item{thread.jthread.cons                   \ref{thread.jthread.cons}}
\item{thread.jthread.mem                    \ref{thread.jthread.mem}}
\item{thread.thread.this                    \ref{thread.thread.this}}
\item{thread.mutex.requirements.mutex       \ref{thread.mutex.requirements.mutex}}
\item{thread.mutex.class                    \ref{thread.mutex.class}}
\item{thread.mutex.recursive                \ref{thread.mutex.recursive}}
\item{thread.timedmutex.requirements        \ref{thread.timedmutex.requirements}}
\item{thread.timedmutex.class               \ref{thread.timedmutex.class}}
\item{thread.timedmutex.recursive           \ref{thread.timedmutex.recursive}}
\item{thread.sharedmutex.requirements       \ref{thread.sharedmutex.requirements}}
\item{thread.sharedmutex.class              \ref{thread.sharedmutex.class}}
\item{thread.sharedtimedmutex.requirements  \ref{thread.sharedtimedmutex.requirements}}
\item{thread.sharedtimedmutex.class         \ref{thread.sharedtimedmutex.class}}
\item{thread.lock                           \ref{thread.lock}}
\item{thread.lock.guard                     \ref{thread.lock.guard}}
\item{thread.lock.scoped                    \ref{thread.lock.scoped}}
\item{thread.lock.unique                    \ref{thread.lock.unique}}
\item{thread.lock.unique.cons               \ref{thread.lock.unique.cons}}
\item{thread.lock.unique.locking            \ref{thread.lock.unique.locking}}
\item{thread.lock.shared                    \ref{thread.lock.shared}}
\item{thread.lock.shared.cons               \ref{thread.lock.shared.cons}}
\item{thread.lock.algorithm                 \ref{thread.lock.algorithm}}
\item{thread.once.onceflag                  \ref{thread.once.onceflag}}
\item{thread.once.callonce                  \ref{thread.once.callonce}}
\item{thread.condition                      \ref{thread.condition}}
\item{thread.condition.nonmember            \ref{thread.condition.nonmember}}
\item{thread.condition.condvar              \ref{thread.condition.condvar}}
\item{thread.condition.condvarany           \ref{thread.condition.condvarany}}
\item{futures.errors                        \ref{futures.errors}}
\item{futures.future_error                  \ref{futures.future.error}}
\item{futures.state                         \ref{futures.state}}
\item{futures.promise                       \ref{futures.promise}}
\item{futures.unique_future                 \ref{futures.unique.future}}
\item{futures.shared_future                 \ref{futures.shared.future}}
\item{futures.async                         \ref{futures.async}}
\item{futures.task.members                  \ref{futures.task.members}}

\end{itemize}
\end{multicols}

Changes from R2:
\begin{itemize}
\item{Changed order of Constraints and Mandates.}
\item{ thread.req.paramname \ref{thread.req.paramname} p1: revert to 'shalls'}
\item{ thread.req.exceptions \ref{thread.req.exceptions} p1:  shal -> shall}
\item{ thread.req.timing \ref{thread.req.timing} p4: make note normative}
\item{ thread.thread.constr \ref{thread.thread.constr} p1: add \removed{that}}
\item{ thread.thread.destr \ref{thread.thread.destr}  p1: should be effects}
\item{ thread.mutex.requirements.mutex \ref{thread.mutex.requirements.mutex} p1 and p2 de-shall}
\item{ thread.mutex.class \ref{thread.mutex.class} p4: can -> might}
\item{ thread.mutex.recursive \ref{thread.mutex.recursive} p3: can -> may}
\item{ thread.timedmutex.recursive \ref{thread.timedmutex.recursive} p3: can -> may}
\item{ thread.lock.unique \ref{thread.lock.unique} p1: can -> may}
\item{ thread.lock.unique.cons \ref{thread.lock.unique.cons} p8, p15, p18: remove shall}
\item{ thread.lock.unique.locking \ref{thread.lock.unique.locking} p5, p11, p17: remove shall}
\item{ thread.lock.shared \ref{thread.lock.shared} p1: can -> may}
\item{ thread.lock.algorithm \ref{thread.lock.algorithm} p1, p4: remove shall}
\item{ thread.thread.constr \ref{thread.thread.constr}, thread.jthread.cons \ref{thread.jthread.cons}, and futures.async \ref{futures.async} change INVOKE}
\item{ thread.req.lockable.basic \ref{thread.req.lockable.basic} p2: convert back to shall}
\item{ thread.req.lockable.req \ref{thread.req.lockable.req} p2: convert back to shall}
\item{ thread.jthread.cons \ref{thread.jthread.cons} use stop_token in mandate, add missing requirement to expects}
\item{ thread.once.callonce \ref{thread.once.callonce} p1: add missing requires to removed block}
\item{ futures.promise \ref{futures.promise} p3: remove shall from expects}
\item{ thread.thread.constr \ref{thread.thread.constr} use decay_t in expects}
\item{ futures.async \ref{futures.async} p3: use decay_t in expects}
\item{ futures.task.members \ref{futures.task.members} p6: remove changes}
\end{itemize}

\vspace*{\fill}

Help for the editors: The changes here can be viewed as latex sources with the following commands
\begin{verbatim}
git clone git@github.com:dsunder/draft.git dsunder-draft
cd dsunder-draft
git diff master..P1622 -- source/threads.tex
\end{verbatim}


\textit{Sandia National Laboratories is a multimission laboratory managed and operated
by National Technology \& Engineering Solutions of Sandia, LLC, a wholly owned
subsidiary of Honeywell International Inc., for the U.S. Department of Energyâ€™s
National Nuclear Security Administration under contract DE-NA0003525.
}
\newpage
